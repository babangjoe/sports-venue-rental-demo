[
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "8cec8530-1d80-4071-b315-e1e4702f7d5e",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC001-user login with valid credentials",
    "description": "Test the /api/auth/login endpoint with valid username and password to ensure successful login and JWT token generation with HTTP-only cookie.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\ndef test_user_login_with_valid_credentials():\n    url = BASE_URL + LOGIN_ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    # Replace with valid credentials as needed\n    payload = {\n        \"username\": \"validUser\",\n        \"password\": \"validPassword123\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\n    # Expect HTTP 200 OK\n    assert response.status_code == 200, f\"Expected status 200 but got {response.status_code}\"\n\n    # Validate response content type is JSON (assuming it returns user info JSON)\n    content_type = response.headers.get(\"Content-Type\", \"\")\n    assert \"application/json\" in content_type, f\"Expected 'application/json' in Content-Type but got '{content_type}'\"\n\n    # Validate response JSON has expected fields (light verification)\n    try:\n        json_data = response.json()\n    except ValueError:\n        assert False, \"Response body is not valid JSON\"\n\n    # Basic check for user info presence (not fully specified, so checking for username or id or token)\n    assert isinstance(json_data, dict), \"Response JSON is not an object\"\n    # The API doc doesn't specify response schema except description, so just check json is non-empty\n    assert json_data, \"Response JSON is empty\"\n\n    # Check that 'set-cookie' header exists with httpOnly and JWT presence indication\n    set_cookie = response.headers.get(\"Set-Cookie\", \"\")\n    assert set_cookie, \"Set-Cookie header is missing in response\"\n    assert \"HttpOnly\" in set_cookie, \"Set-Cookie header missing HttpOnly flag\"\n    assert \"jwt\" in set_cookie.lower() or \"token\" in set_cookie.lower(), \"Set-Cookie header does not appear to include JWT token\"\n\ntest_user_login_with_valid_credentials()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.014Z",
    "modified": "2025-12-07T14:53:55.012Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "1484021b-04a9-4536-ac0b-5126c4bab67d",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC002-user login with missing credentials",
    "description": "Test the /api/auth/login endpoint with missing username or password fields to verify the API returns a 400 error for missing credentials.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/auth/login\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_user_login_with_missing_credentials():\n    # Test cases with missing username or password fields\n    test_payloads = [\n        {},  # Missing both username and password\n        {\"username\": \"someuser\"},  # Missing password\n        {\"password\": \"somepass\"},  # Missing username\n        {\"username\": \"\"},          # Empty username\n        {\"password\": \"\"},          # Empty password\n        {\"username\": \"\", \"password\": \"somepass\"},  # Empty username with password\n        {\"username\": \"someuser\", \"password\": \"\"},  # Username with empty password\n    ]\n\n    for payload in test_payloads:\n        try:\n            response = requests.post(LOGIN_ENDPOINT, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Request failed: {e}\"\n\n        # The API should respond with status code 400 for missing credentials\n        assert response.status_code == 400, f\"Expected 400 status for payload {payload}, got {response.status_code}\"\n\n\ntest_user_login_with_missing_credentials()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.022Z",
    "modified": "2025-12-07T14:53:55.019Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "b148f856-a34a-41aa-b3c9-7d492d642f8e",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC003-user login with invalid credentials",
    "description": "Test the /api/auth/login endpoint with incorrect username or password to confirm the API returns a 401 error for invalid credentials.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\ndef test_user_login_with_invalid_credentials():\n    url = BASE_URL + LOGIN_ENDPOINT\n    headers = {\"Content-Type\": \"application/json\"}\n    payload = {\n        \"username\": \"invalid_user\",\n        \"password\": \"wrong_password\"\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    assert response.status_code == 401, f\"Expected status code 401, got {response.status_code}\"\n    # Optionally check response content for error message if any\n    try:\n        data = response.json()\n    except ValueError:\n        data = None\n    # The API spec doesn't provide exact error JSON, so no further checks here\n\ntest_user_login_with_invalid_credentials()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.028Z",
    "modified": "2025-12-07T14:53:55.026Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "cb4dd519-0678-451b-9c0a-0aaaa19e7ae7",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC004-create booking with valid data and no time slot conflict",
    "description": "Test the POST /api/booking endpoint with valid booking data ensuring no time slot conflicts to verify successful booking creation with 201 response.",
    "code": "import requests\nfrom datetime import datetime, timedelta\nimport random\nimport string\n\nBASE_URL = \"http://localhost:4000\"\nTIMEOUT = 30\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\ndef test_create_booking_with_valid_data_no_conflict():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Step 1: Create a new sport (required to create a field)\n    sport_payload = {\n        \"sport_name\": f\"Sport_{random_string()}\",\n        \"sport_type\": \"Outdoor\"\n    }\n    sport_resp = requests.post(f\"{BASE_URL}/api/sports\", json=sport_payload, headers=headers, timeout=TIMEOUT)\n    assert sport_resp.status_code == 201, f\"Failed to create sport: {sport_resp.text}\"\n\n    sport_data = sport_resp.json()\n    sport_id = sport_data.get(\"id\")\n    assert sport_id is not None, \"Sport ID not returned on sport creation\"\n\n    # Step 2: Create a new field under this sport\n    field_payload = {\n        \"field_name\": f\"Field_{random_string()}\",\n        \"field_code\": f\"FC_{random_string(5)}\",\n        \"sport_id\": sport_id,\n        \"price_per_hour\": 100.0,\n        \"description\": \"Test field for booking\",\n        \"url_image\": \"http://example.com/image.jpg\",\n        \"is_available\": True\n    }\n    field_resp = requests.post(f\"{BASE_URL}/api/fields\", json=field_payload, headers=headers, timeout=TIMEOUT)\n    assert field_resp.status_code == 201, f\"Failed to create field: {field_resp.text}\"\n\n    field_data = field_resp.json()\n    field_id = field_data.get(\"id\")\n    field_name = field_data.get(\"field_name\")\n    assert field_id is not None and field_name is not None, \"Field ID or name not returned on field creation\"\n\n    # Prepare booking data:\n    booking_date = (datetime.now() + timedelta(days=1)).strftime(\"%Y-%m-%d\")  # tomorrow\n    time_slots = [\"09:00-10:00\", \"10:00-11:00\"]  # assume these slots exist and are not booked\n    total_price = len(time_slots) * 100.0  # price per hour * number of slots\n\n    booking_payload = {\n        \"field_id\": field_id,\n        \"field_name\": field_name,\n        \"booking_date\": booking_date,\n        \"time_slots\": time_slots,\n        \"total_price\": total_price,\n        \"customer_name\": \"Test Customer\",\n        \"customer_phone\": \"081234567890\",\n        \"customer_email\": \"test.customer@example.com\"\n    }\n\n    booking_id = None\n    try:\n        booking_resp = requests.post(f\"{BASE_URL}/api/booking\", json=booking_payload, headers=headers, timeout=TIMEOUT)\n        assert booking_resp.status_code == 201, f\"Expected 201, got {booking_resp.status_code}, Response: {booking_resp.text}\"\n        booking_resp_json = booking_resp.json()\n        booking_id = booking_resp_json.get(\"id\")\n        assert booking_id is not None, \"Booking ID not returned after creation\"\n        assert booking_resp_json.get(\"field_id\") == field_id\n        assert booking_resp_json.get(\"booking_date\") == booking_date\n        assert booking_resp_json.get(\"time_slots\") == time_slots\n    finally:\n        # Clean up: delete booking if created\n        if booking_id is not None:\n            try:\n                requests.delete(f\"{BASE_URL}/api/booking/{booking_id}\", timeout=TIMEOUT)\n            except Exception:\n                pass\n\n        # Clean up: delete the field created\n        if field_id is not None:\n            try:\n                requests.delete(f\"{BASE_URL}/api/fields/{field_id}\", timeout=TIMEOUT)\n            except Exception:\n                pass\n\n        # Clean up: delete the sport created\n        if sport_id is not None:\n            try:\n                requests.delete(f\"{BASE_URL}/api/sports/{sport_id}\", timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_create_booking_with_valid_data_no_conflict()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.034Z",
    "modified": "2025-12-07T14:53:55.033Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "10b34893-727c-4b3f-8613-043c25f58c5c",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC005-create booking with missing required fields",
    "description": "Test the POST /api/booking endpoint with missing required fields to ensure the API returns a 400 error indicating missing required fields.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nTIMEOUT = 30\n\ndef test_create_booking_with_missing_required_fields():\n    url = f\"{BASE_URL}/api/booking\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    # Missing required fields: field_id, field_name, booking_date, time_slots, total_price\n    # Provide an empty payload or partial payload missing required fields\n    payload = {\n        # purposely leaving out required fields\n        \"customer_name\": \"John Doe\",\n        \"customer_phone\": \"08123456789\",\n        \"customer_email\": \"john.doe@example.com\"\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # The API should return 400 for missing required fields\n    assert response.status_code == 400, f\"Expected status code 400 but got {response.status_code}\"\n    # Optionally assert on response content indicating missing fields\n    try:\n        resp_json = response.json()\n        assert (\"missing\" in str(resp_json).lower()) or (\"required\" in str(resp_json).lower()), \\\n            \"Response does not indicate missing required fields\"\n    except ValueError:\n        # Response is not valid JSON, that's acceptable as long as status code is 400\n        pass\n\ntest_create_booking_with_missing_required_fields()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.040Z",
    "modified": "2025-12-07T14:53:55.040Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "07ae9b56-052f-468e-af85-ff2e43770106",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC006-create booking with time slot conflict",
    "description": "Test the POST /api/booking endpoint by attempting to book a time slot that conflicts with an existing booking to verify the API returns a 409 conflict error.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:4000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_create_booking_with_time_slot_conflict():\n    # Step 1: Prepare unique sport\n    sport_payload = {\n        \"sport_name\": \"Tennis Test Sport Conflict\",\n        \"sport_type\": \"racket\",\n        \"description\": \"Sport for conflict booking test\",\n        \"is_available\": True\n    }\n    sport_resp = requests.post(f\"{BASE_URL}/api/sports\", json=sport_payload, headers=HEADERS, timeout=TIMEOUT)\n    assert sport_resp.status_code == 201, f\"Failed to create sport, got {sport_resp.status_code}\"\n    sport_id = sport_resp.json().get(\"id\")\n    assert sport_id is not None, \"Sport creation response missing 'id'\"\n\n    # Step 2: Prepare unique field under the sport\n    field_payload = {\n        \"field_name\": \"Tennis Court Conflict Test\",\n        \"field_code\": \"TCCT123\",\n        \"sport_id\": sport_id,\n        \"price_per_hour\": 150,\n        \"description\": \"Field for conflict booking test\",\n        \"url_image\": \"\",\n        \"is_available\": True\n    }\n    field_resp = requests.post(f\"{BASE_URL}/api/fields\", json=field_payload, headers=HEADERS, timeout=TIMEOUT)\n    assert field_resp.status_code == 201, f\"Failed to create field, got {field_resp.status_code}\"\n    field_id = field_resp.json().get(\"id\")\n    field_name = field_payload[\"field_name\"]\n    assert field_id is not None, \"Field creation response missing 'id'\"\n\n    booking_date = datetime.date.today().isoformat()\n    booking_payload_1 = {\n        \"field_id\": field_id,\n        \"field_name\": field_name,\n        \"booking_date\": booking_date,\n        \"time_slots\": [\"10:00-11:00\"],\n        \"total_price\": 150,\n        \"customer_name\": \"First Customer\",\n        \"customer_phone\": \"1234567890\",\n        \"customer_email\": \"firstcustomer@example.com\"\n    }\n    booking_payload_conflict = {\n        \"field_id\": field_id,\n        \"field_name\": field_name,\n        \"booking_date\": booking_date,\n        \"time_slots\": [\"10:00-11:00\"],  # same time slot to cause conflict\n        \"total_price\": 150,\n        \"customer_name\": \"Second Customer\",\n        \"customer_phone\": \"0987654321\",\n        \"customer_email\": \"secondcustomer@example.com\"\n    }\n\n    try:\n        # Step 3: Create initial booking (should succeed)\n        create_resp_1 = requests.post(f\"{BASE_URL}/api/booking\", json=booking_payload_1, headers=HEADERS, timeout=TIMEOUT)\n        assert create_resp_1.status_code == 201, f\"Failed to create initial booking, got {create_resp_1.status_code}\"\n        booking_id_1 = create_resp_1.json().get(\"id\")\n        assert booking_id_1 is not None, \"Initial booking creation missing 'id'\"\n\n        # Step 4: Attempt to create conflicting booking (should fail with 409)\n        create_resp_2 = requests.post(f\"{BASE_URL}/api/booking\", json=booking_payload_conflict, headers=HEADERS, timeout=TIMEOUT)\n        assert create_resp_2.status_code == 409, f\"Time slot conflict test failed, expected 409 got {create_resp_2.status_code}\"\n    finally:\n        # Cleanup bookings and resources if deletion endpoints available\n        # No deletion endpoints defined in PRD, so skipping cleanup for bookings\n\n        # Delete created field\n        if field_id is not None:\n            requests.delete(f\"{BASE_URL}/api/fields/{field_id}\", timeout=TIMEOUT)\n        # Delete created sport\n        if sport_id is not None:\n            requests.delete(f\"{BASE_URL}/api/sports/{sport_id}\", timeout=TIMEOUT)\n\n\ntest_create_booking_with_time_slot_conflict()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.046Z",
    "modified": "2025-12-07T14:53:55.047Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "5996400c-7c25-489a-a39e-5cb43e3db31d",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC007-get bookings with filters",
    "description": "Test the GET /api/booking endpoint with query parameters like fieldId, date, and status to verify the API returns filtered booking lists correctly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nTIMEOUT = 30\n\ndef test_get_bookings_with_filters():\n    # Define filter parameters for the GET request\n    params = {\n        \"fieldId\": 1,\n        \"date\": \"2025-12-15\",\n        \"status\": \"confirmed\"\n    }\n    try:\n        response = requests.get(\n            f\"{BASE_URL}/api/booking\",\n            params=params,\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Validate response status code\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    bookings = response.json()\n    assert isinstance(bookings, list), f\"Expected response to be a list, got {type(bookings)}\"\n\n    # Validate that each booking matches the filter criteria if fields are present\n    for booking in bookings:\n        # Check fieldId match if field_id present\n        if \"field_id\" in booking:\n            assert booking[\"field_id\"] == params[\"fieldId\"], f\"Booking field_id {booking['field_id']} does not match filter {params['fieldId']}\"\n        # Check booking_date match if booking_date present\n        if \"booking_date\" in booking:\n            assert booking[\"booking_date\"] == params[\"date\"], f\"Booking date {booking['booking_date']} does not match filter {params['date']}\"\n        # Check status match if status present\n        if \"status\" in booking:\n            assert booking[\"status\"] == params[\"status\"], f\"Booking status {booking['status']} does not match filter {params['status']}\"\n\ntest_get_bookings_with_filters()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.052Z",
    "modified": "2025-12-07T14:53:55.054Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "19f81ae3-2821-48e6-b2ab-b9cf4e42af71",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC008-create new field with valid data",
    "description": "Test the POST /api/fields endpoint with valid field data including field name, code, sport id, and price per hour to verify successful field creation with 201 response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nFIELDS_ENDPOINT = f\"{BASE_URL}/api/fields\"\nTIMEOUT = 30\n\ndef test_create_new_field_with_valid_data():\n    # Sample valid field data\n    field_data = {\n        \"field_name\": \"Test Field Alpha\",\n        \"field_code\": \"TFALPHA001\",\n        \"sport_id\": 1,\n        \"price_per_hour\": 150000,\n        \"description\": \"A test field created for automated testing.\",\n        \"url_image\": \"http://example.com/image.png\",\n        \"is_available\": True\n    }\n    field_id = None\n\n    try:\n        # POST request to create a new field\n        response = requests.post(\n            FIELDS_ENDPOINT,\n            json=field_data,\n            timeout=TIMEOUT\n        )\n        # Assert HTTP 201 Created\n        assert response.status_code == 201, f\"Expected status code 201, got {response.status_code}\"\n\n        # Validate response contains the created field data and an ID\n        resp_json = response.json()\n        assert isinstance(resp_json, dict), \"Response is not a JSON object\"\n        assert \"field_name\" in resp_json and resp_json[\"field_name\"] == field_data[\"field_name\"]\n        assert \"field_code\" in resp_json and resp_json[\"field_code\"] == field_data[\"field_code\"]\n        assert \"sport_id\" in resp_json and resp_json[\"sport_id\"] == field_data[\"sport_id\"]\n        assert \"price_per_hour\" in resp_json and resp_json[\"price_per_hour\"] == field_data[\"price_per_hour\"]\n        assert \"id\" in resp_json, \"Response JSON does not contain 'id'\"\n        field_id = resp_json[\"id\"]\n\n    finally:\n        # Cleanup: delete the created field if creation was successful\n        if field_id is not None:\n            try:\n                del_response = requests.delete(\n                    f\"{FIELDS_ENDPOINT}/{field_id}\",\n                    timeout=TIMEOUT\n                )\n                # Optional: check delete status, but not assert here to avoid masking original test result\n            except Exception:\n                pass\n\ntest_create_new_field_with_valid_data()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.058Z",
    "modified": "2025-12-07T14:53:55.061Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "235eede5-97ff-449a-af3e-73f59b143d13",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC009-get all fields with availability filter",
    "description": "Test the GET /api/fields endpoint with isAvailable and sportId query parameters to verify the API returns the correct list of fields filtered by availability and sport.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nTIMEOUT = 30\n\ndef test_get_all_fields_with_availability_filter():\n    # Step 1: Create a sport to associate with fields\n    sport_payload = {\n        \"sport_name\": \"Test Sport TC009\",\n        \"sport_type\": \"Indoor\"\n    }\n    sport_id = None\n    field_id_available = None\n    field_id_unavailable = None\n    try:\n        sport_resp = requests.post(\n            f\"{BASE_URL}/api/sports\",\n            json=sport_payload,\n            timeout=TIMEOUT\n        )\n        assert sport_resp.status_code == 201, f\"Failed to create sport, status: {sport_resp.status_code}, response: {sport_resp.text}\"\n        sport_data = sport_resp.json()\n        # Assuming the created sport ID is returned in the response JSON as 'id' or similar\n        if isinstance(sport_data, dict) and \"id\" in sport_data:\n            sport_id = sport_data[\"id\"]\n        elif isinstance(sport_data, dict) and \"sport_id\" in sport_data:\n            sport_id = sport_data[\"sport_id\"]\n        else:\n            # fallback: try keys typical to APIs\n            keys = list(sport_data.keys())\n            if keys:\n                sport_id = sport_data[keys[0]].get(\"id\") or sport_data[keys[0]].get(\"sport_id\")\n        assert sport_id is not None, \"Sport ID not found in creation response\"\n\n        # Step 2: Create one available field for the sport\n        field_payload_available = {\n            \"field_name\": \"Available Field TC009\",\n            \"field_code\": \"TC009-A\",\n            \"sport_id\": sport_id,\n            \"price_per_hour\": 100.0,\n            \"description\": \"Available field for TC009 test\",\n            \"url_image\": \"http://example.com/image-available.jpg\",\n            \"is_available\": True\n        }\n        field_resp = requests.post(\n            f\"{BASE_URL}/api/fields\",\n            json=field_payload_available,\n            timeout=TIMEOUT\n        )\n        assert field_resp.status_code == 201, f\"Failed to create available field, status: {field_resp.status_code}, response: {field_resp.text}\"\n        field_data = field_resp.json()\n        if isinstance(field_data, dict) and \"id\" in field_data:\n            field_id_available = field_data[\"id\"]\n        elif isinstance(field_data, dict) and \"field_id\" in field_data:\n            field_id_available = field_data[\"field_id\"]\n        else:\n            keys = list(field_data.keys())\n            if keys:\n                field_id_available = field_data[keys[0]].get(\"id\") or field_data[keys[0]].get(\"field_id\")\n        assert field_id_available is not None, \"Available Field ID not found in response\"\n\n        # Step 3: Create one unavailable field for the sport\n        field_payload_unavailable = {\n            \"field_name\": \"Unavailable Field TC009\",\n            \"field_code\": \"TC009-U\",\n            \"sport_id\": sport_id,\n            \"price_per_hour\": 90.0,\n            \"description\": \"Unavailable field for TC009 test\",\n            \"url_image\": \"http://example.com/image-unavailable.jpg\",\n            \"is_available\": False\n        }\n        field_resp_unavailable = requests.post(\n            f\"{BASE_URL}/api/fields\",\n            json=field_payload_unavailable,\n            timeout=TIMEOUT\n        )\n        assert field_resp_unavailable.status_code == 201, f\"Failed to create unavailable field, status: {field_resp_unavailable.status_code}, response: {field_resp_unavailable.text}\"\n        field_data_unavailable = field_resp_unavailable.json()\n        if isinstance(field_data_unavailable, dict) and \"id\" in field_data_unavailable:\n            field_id_unavailable = field_data_unavailable[\"id\"]\n        elif isinstance(field_data_unavailable, dict) and \"field_id\" in field_data_unavailable:\n            field_id_unavailable = field_data_unavailable[\"field_id\"]\n        else:\n            keys = list(field_data_unavailable.keys())\n            if keys:\n                field_id_unavailable = field_data_unavailable[keys[0]].get(\"id\") or field_data_unavailable[keys[0]].get(\"field_id\")\n        assert field_id_unavailable is not None, \"Unavailable Field ID not found in response\"\n\n        # Step 4: Call GET /api/fields with isAvailable=True and sportId filter\n        params = {\n            \"isAvailable\": True,\n            \"sportId\": sport_id\n        }\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/fields\",\n            params=params,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"GET /api/fields returned status {get_resp.status_code}\"\n        fields_list = get_resp.json()\n        assert isinstance(fields_list, list), \"Response is not a list\"\n\n        # Step 5: Validate that only available fields for the sport are included\n        # Normalize matching for ids with 'id' or 'field_id'\n        def get_field_id(field):\n            return field.get('id') or field.get('field_id')\n\n        def get_is_available(field):\n            # Accept 'is_available' or 'isAvailable'\n            val = field.get('is_available')\n            if val is None:\n                val = field.get('isAvailable')\n            return val\n\n        def get_sport_id(field):\n            val = field.get('sport_id')\n            if val is None:\n                val = field.get('sportId')\n            return val\n\n        # Assert available field is found\n        assert any(get_field_id(f) == field_id_available for f in fields_list), \"Available field not found in filtered list\"\n\n        # Assert all returned fields match filter criteria\n        assert all(\n            get_is_available(f) is True and\n            get_sport_id(f) == sport_id\n            for f in fields_list\n        ), \"Returned fields do not match filter criteria\"\n\n        # Assert unavailable field is not included\n        assert all(get_field_id(f) != field_id_unavailable for f in fields_list), \"Unavailable field found in filtered list\"\n        \n    finally:\n        # Cleanup: delete created fields\n        if field_id_available is not None:\n            requests.delete(f\"{BASE_URL}/api/fields/{field_id_available}\", timeout=TIMEOUT)\n        if field_id_unavailable is not None:\n            requests.delete(f\"{BASE_URL}/api/fields/{field_id_unavailable}\", timeout=TIMEOUT)\n        # Cleanup: delete created sport\n        if sport_id is not None:\n            requests.delete(f\"{BASE_URL}/api/sports/{sport_id}\", timeout=TIMEOUT)\n\ntest_get_all_fields_with_availability_filter()\n",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.065Z",
    "modified": "2025-12-07T14:53:55.069Z"
  },
  {
    "projectId": "183fb8e8-f728-44ae-9922-578e6a56dcd4",
    "testId": "3486a6db-e2d9-4298-936c-32a3e2675f92",
    "userId": "f4e80478-b0c1-7005-5dd8-8bc3543a397a",
    "title": "TC010-create new sport with valid data",
    "description": "Test the POST /api/sports endpoint with valid sport name and type to verify successful creation of a new sport category with 201 response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:4000\"\nSPORTS_ENDPOINT = f\"{BASE_URL}/api/sports\"\nTIMEOUT = 30\n\ndef test_create_new_sport_with_valid_data():\n    sport_data = {\n        \"sport_name\": \"Test Sport Name\",\n        \"sport_type\": \"Indoor\",\n        \"description\": \"Automated test sport creation\",\n        \"is_available\": True\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    created_sport_id = None\n    try:\n        # Create new sport\n        response = requests.post(SPORTS_ENDPOINT, json=sport_data, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code}\"\n        resp_json = response.json()\n        # Expect response to contain at least the created resource identifier or the sent data echo\n        # (No explicit schema provided for response body, so we verify the required fields)\n        assert \"sport_name\" in resp_json or \"id\" in resp_json, \"Response missing expected fields\"\n        if \"id\" in resp_json:\n            created_sport_id = resp_json[\"id\"]\n    finally:\n        # Cleanup: delete the created sport if ID is available\n        if created_sport_id is not None:\n            delete_url = f\"{SPORTS_ENDPOINT}/{created_sport_id}\"\n            try:\n                del_resp = requests.delete(delete_url, timeout=TIMEOUT)\n                # Accept 200 or 204 for successful deletion\n                assert del_resp.status_code in (200, 204), f\"Failed to delete sport in cleanup, status: {del_resp.status_code}\"\n            except Exception:\n                pass\n\ntest_create_new_sport_with_valid_data()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-07T14:43:50.070Z",
    "modified": "2025-12-07T14:53:55.076Z"
  }
]
